{"name":"Deride","tagline":"Mocking library based on composition","body":"# deride [![Build Status](https://travis-ci.org/guzzlerio/deride.svg?branch=master)](https://travis-ci.org/guzzlerio/deride) [![NPM version](https://badge.fury.io/js/deride.svg)](http://badge.fury.io/js/deride) [![Dependency Status](https://david-dm.org/guzzlerio/deride.svg)](https://david-dm.org/guzzlerio/deride) [![Stories in Ready](https://badge.waffle.io/guzzlerio/deride.png?label=ready&title=Ready)](https://waffle.io/guzzlerio/deride) [![Stories In Progress](https://badge.waffle.io/guzzlerio/deride.png?label=in%20progress&title=In%20Progres)](https://waffle.io/guzzlerio/deride) \r\n\r\n[![NPM](https://nodei.co/npm/deride.png?downloadRank=true&downloads=true)](https://nodei.co/npm/deride/)\r\n\r\nMocking library based on composition\r\n\r\nThe inspiration for this was that my colleague was having a look at other mocking frameworks and mentioned to me that they do not work when using ```Object.freeze``` in the objects to enforce encapsulation.  This library builds on composition to create a mocking library that can work with objects which are frozen.\r\n## Getting Started\r\nInstall the module with: `npm install deride`\r\n\r\n```javascript\r\nvar deride = require('deride');\r\n```\r\n\r\n## Documentation\r\n\r\n### Mocking\r\n\r\n- deride.wrap(obj)\r\n\r\n**CAUTION** Remember when you use this function about the good practice recommended in the book **Growing Object-Oriented Software, Guided by Tests**  ***Chapter 8: Only Mock Types That You Own***\r\n\r\n- [deride.stub(methods)](#stub-methods)\r\n  - **methods** Array\r\n- [deride.stub(obj)](#stub-obj)\r\n  - **obj** Object\r\n- [deride.func()](#func)\r\n\r\n### Expectations\r\n\r\n- [```obj```.expect.```method```.called.times(n)](#called-times)\r\n- [```obj```.expect.```method```.called.once()](#called-once)\r\n- [```obj```.expect.```method```.called.twice()](#called-once)\r\n- [```obj```.expect.```method```.called.never()](#called-never)\r\n- [```obj```.expect.```method```.called.withArg(arg)](#called-witharg)\r\n- [```obj```.expect.```method```.called.withArgs(args)](#called-withargs)\r\n\r\n**All of the above can be negated e.g. negating the `.withArgs` would be: ** \r\n\r\n- ```obj```.expect.```method```.called`.not`.withArgs(args)\r\n\r\n### Resetting the counts / called with args\r\n- [```obj```.expect.```method```.called.reset()](#called-reset)\r\n- ```obj```.called.reset()\r\n\r\n### Setup\r\n\r\n- [```obj```.setup.```method```.toDoThis(func)](#setup-todothis)\r\n- [```obj```.setup.```method```.toReturn(value)](#setup-toreturn)\r\n- [```obj```.setup.```method```.toResolveWith(value)](#setup-promise-resolve)\r\n- [```obj```.setup.```method```.toRejectWith(value)](#setup-promise-reject)\r\n- [```obj```.setup.```method```.toThrow(message)](#setup-tothrow)\r\n- [```obj```.setup.```method```.toEmit(event, args)](#events)\r\n- [```obj```.setup.```method```.toCallbackWith(args)](#setup-tocallback)\r\n- [```obj```.setup.```method```.toTimeWarp(milliseconds)](#setup-totimewarp)\r\n- [```obj```.setup.```method```.when(args).[toDoThis|toReturn|toRejectWith|toResolveWith|toThrow|toEmit|toCallbackWith|toTimeWarp]](#setup-toreturn-when)\r\n\r\n## Examples\r\n\r\n### The context\r\n```javascript\r\nvar Person = function(name) {\r\n    return Object.freeze({\r\n        greet: function(otherPersonName) {\r\n            console.log(name, 'says hello to', otherPersonName);\r\n        },\r\n\t\techo: function(name) {\r\n\t\t\treturn name;\r\n\t\t}\r\n    });\r\n}\r\n```\r\n\r\n<a name=\"stub-methods\" />\r\n\r\n### Creating a stubbed object\r\nStubbing an object simply creates an anonymous object, with all the method specified and then the object is wrapped to provide all the expectation functionality of the library\r\n\r\n\r\n```javascript\r\nvar bob = deride.stub(['greet']);\r\nbob.greet('alice');\r\nbob.expect.greet.called.times(1);\r\n```\r\n\r\n<a name=\"stub-obj\" />\r\n\r\n### Creating a stubbed object based on an existing object\r\n```javascript\r\nvar Person = {\r\n    greet: function(name) {\r\n        return 'alice sas hello to ' + name;\r\n    },\r\n};\r\nvar bob = deride.stub(Person);\r\nbob.greet('alice');\r\nbob.expect.greet.called.once();\r\n```\r\n\r\n<a name=\"func\" />\r\n\r\n### Creating a single mocked method\r\n```javascript\r\nvar func = deride.func();\r\nfunc.setup.toReturn(1);\r\nvar value = func(1, 2, 3);\r\nassert.equal(value, 1);\r\n```\r\n\r\n## Events\r\n\r\n### Force the emit of an event on an object\r\n```javascript\r\nvar bob = deride.stub([]);\r\nbob.on('message', function() {\r\n    done();\r\n});\r\nbob.emit('message', 'payload');\r\n```\r\n\r\n### Emit an event on method invocation\r\n```javascript\r\nbob.setup.greet.toEmit('testing');\r\nbob.on('testing', function() {\r\n\tdone();\r\n});\r\nbob.greet('bob');\r\n```\r\n\r\n### Emit an event with args on method invocation\r\n```javascript\r\nbob.setup.greet.toEmit('testing', 'arg1', { a: 1 });\r\nbob.on('testing', function(a1, a2) {\r\n\ta1.should.eql('arg1');\r\n\ta2.should.eql({ a: 1 });\r\n\tdone();\r\n});\r\nbob.greet('bob');\r\n```\r\n\r\n\r\n<a name=\"called-times\" />\r\n\r\n### Count the number of invocations of a method\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.greet('alice');\r\nbob.expect.greet.called.times(1);\r\n```\r\n\r\n<a name=\"called-once\" />\r\n\r\n### Has convenience methods for invocation counts\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.greet('alice');\r\nbob.expect.greet.called.once();\r\nbob.greet('sally');\r\nbob.expect.greet.called.twice();\r\n```\r\n\r\n<a name=\"called-never\" />\r\n\r\n### Determine if a method has **never** been called\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.expect.greet.called.never();\r\n```\r\n\r\n<a name=\"called-reset\" />\r\n\r\n### Resetting the called count on **all** methods\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.greet('alice');\r\nbob.echo('alice');\r\nbob.expect.greet.called.once();\r\nbob.expect.echo.called.once();\r\n\r\nbob.called.reset();\r\n\r\nbob.expect.greet.called.never();\r\nbob.expect.echo.called.never();\r\n```\r\n\r\n<a name=\"called-withargs\" />\r\n\r\n### Determine if a method was called with a specific set of arguments\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.greet('alice');\r\nbob.greet('bob');\r\nbob.expect.greet.called.withArgs('bob');\r\n```\r\n\r\n<a name=\"setup-todothis\" />\r\n\r\n### Override the method body to change the invocation\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.toDoThis(function(otherPersonName) {\r\n    return util.format('yo %s', otherPersonName);\r\n});\r\nvar result = bob.greet('alice');\r\nresult.should.eql('yo alice');\r\n```\r\n\r\n<a name=\"setup-toreturn\" />\r\n\r\n### Override the return value for a function\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.toReturn('foobar');\r\nvar result = bob.greet('alice');\r\nresult.should.eql('foobar');\r\n```\r\n\r\n### Overriding the promise resolver for a function\r\n<a name=\"setup-promise-resolve\" />\r\n\r\n#### To resolve with a value\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.toResolveWith('foobar');\r\nbob.greet('alice').then(function(result) {\r\n    result.should.eql('foobar');\r\n});\r\n```\r\n\r\n<a name=\"setup-promise-reject\" />\r\n\r\n#### To reject with a value\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.toRejectWith('foobar');\r\nbob.greet('alice').catch(function(result) {\r\n    result.should.eql('foobar');\r\n});\r\n```\r\n\r\n<a name=\"setup-tothrow\" />\r\n\r\n### Force a method invocation to throw a specific error\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.toThrow('BANG');\r\nshould(function() {\r\n    bob.greet('alice');\r\n}).\r\nthrow(/BANG/);\r\n```\r\n\r\n<a name=\"setup-tocallback\" />\r\n\r\n## Override the invocation of a callback\r\n\r\n### when there is only one function passed as args\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.chuckle.toCallbackWith(0, 'boom');\r\nbob.chuckle(function(err, message) {\r\n    assert.equal(err, 0);\r\n    assert.equal(message, 'boom');\r\n});\r\n```\r\n\r\n### when the callback is the last arg which is a `function`\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.chuckle.toCallbackWith(0, 'boom');\r\nbob.chuckle('bob', function() {\r\n    done('this was not the callback');\r\n}, function(err, message) {\r\n    assert.equal(err, 0);\r\n    assert.equal(message, 'boom');\r\n    done();\r\n});\r\n```\r\n\r\n<a name=\"setup-totimewarp\" />\r\n\r\n### Accelerating the timeout used internally by a function\r\n```javascript\r\nvar Person = function(name) {\r\n    return Object.freeze({\r\n        foobar: function(timeout, callback) {\r\n            setTimeout(function() {\r\n                callback('result');\r\n            }, timeout);\r\n        }\r\n    });\r\n};\r\nvar timeout = 10000;\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.foobar.toTimeWarp(timeout);\r\nbob.foobar(timeout, function(message) {\r\n    assert.equal(message, 'result');\r\n});\r\n```\r\n\r\n## Setup for specific arguments\r\n\r\n<a name=\"setup-toreturn-when\" />\r\n\r\n### Setting the return value of a function when specific arguments are used\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.when('alice').toReturn('foobar');\r\nbob.setup.greet.toReturn('barfoo');\r\nvar result1 = bob.greet('alice');\r\nvar result2 = bob.greet('bob');\r\nresult1.should.eql('foobar');\r\nresult2.should.eql('barfoo');\r\n```\r\n\r\n<a name=\"setup-todothis-when\" />\r\n\r\n### Overriding a method`s body when specific arguments are provided\r\n``` javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.when('alice').toDoThis(function(otherPersonName) {\r\n    return util.format('yo yo %s', otherPersonName);\r\n});\r\nbob.setup.greet.toDoThis(function(otherPersonName) {\r\n    return util.format('yo %s', otherPersonName);\r\n});\r\nvar result1 = bob.greet('alice');\r\nvar result2 = bob.greet('bob');\r\nresult1.should.eql('yo yo alice');\r\nresult2.should.eql('yo bob');\r\n```\r\n\r\n<a name=\"setup-tothrow-when\" />\r\n\r\n### Throwing an error for a method invocation when specific arguments are provided\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.greet.when('alice').toThrow('BANG');\r\nshould(function() {\r\n    bob.greet('alice');\r\n}).\r\nthrow (/BANG/);\r\nshould(function() {\r\n    bob.greet('bob');\r\n}).not.\r\nthrow (/BANG/);\r\n```\r\n\r\n<a name=\"setup-tocallback-when\" />\r\n\r\n### Override the invocation of a callback when specific arguments are provided\r\n```javascript\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.chuckle.toCallbackWith([0, 'boom']);\r\nbob.setup.chuckle.when('alice').toCallbackWith([0, 'bam']);\r\nbob.chuckle(function(err, message) {\r\n    assert.equal(err, 0);\r\n    assert.equal(message, 'boom');\r\n    bob.chuckle('alice', function(err, message) {\r\n        assert.equal(err, 0);\r\n        assert.equal(message, 'bam');\r\n    });\r\n});\r\n```\r\n\r\n<a name=\"setup-totimewarp-when\" />\r\n\r\n### Accelerating the timeout used internally by a function when specific arguments are provided\r\n```javascript\r\nvar Person = function(name) {\r\n    return Object.freeze({\r\n        foobar: function(timeout, callback) {\r\n            setTimeout(function() {\r\n                callback('result');\r\n            }, timeout);\r\n        }\r\n    });\r\n};\r\nvar timeout1 = 10000;\r\nvar timeout2 = 20000;\r\nvar bob = new Person('bob');\r\nbob = deride.wrap(bob);\r\nbob.setup.foobar.toTimeWarp(timeout1);\r\nbob.setup.foobar.when(timeout2).toTimeWarp(timeout2);\r\nbob.foobar(timeout1, function(message) {\r\n    assert.equal(message, 'result');\r\n    bob.foobar(timeout2, function(message) {\r\n        assert.equal(message, 'result');\r\n        done();\r\n    });\r\n});\r\n\r\n```\r\n\r\n### Provide access to individual calls to a method\r\n\r\n```javascript\r\nvar bob = deride.wrap(bob);\r\nbob.greet('jack', 'alice');\r\nbob.greet('bob');\r\nbob.expect.greet.invocation(0).withArg('alice');\r\nbob.expect.greet.invocation(1).withArg('bob');\r\n```\r\n\r\n## Enable the assertion on a single arg being used in any invocation\r\n\r\n<a name=\"called-witharg\" />\r\n\r\n### when the arg is a primitive object\r\n```javascript\r\nvar bob = deride.wrap(bob);\r\nbob.greet('alice', {\r\n    name: 'bob',\r\n    a: 1\r\n}, 'sam');\r\nbob.expect.greet.called.withArg('sam');\r\n```\r\n\r\n### when the arg is not a primitive object\r\n```javascript\r\nvar bob = deride.wrap(bob);\r\nbob.greet('alice', {\r\n    name: 'bob',\r\n    a: 1\r\n});\r\nbob.expect.greet.called.withArg({\r\n    name: 'bob'\r\n});\r\n```\r\n\r\n## Contributing\r\nPlease ensure that you run ```grunt```, have no style warnings and that all the tests are passing.\r\n\r\n## License\r\nCopyright (c) 2014 Andrew Rea  \r\nCopyright (c) 2014 James Allen\r\n\r\nLicensed under the MIT license.\r\n","google":"UA-2048754-11","note":"Don't delete this file! It's used internally to help with page regeneration."}